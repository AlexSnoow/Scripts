Отличный вопрос. Поскольку ваш скрипт находится в рабочей папке `c:\work\myScript\`, у вас есть два пути
организации модулей:

1.  **Локально (в папке проекта):** Модуль лежит рядом со скриптом. Это делает проект "портативным" (можно
скопировать папку на другой компьютер и все заработает).
2.  **Глобально (в системной папке):** Модуль устанавливается в систему. Если модуль используется многими разными
скриптами в разных местах, это лучший вариант.

Разберем оба варианта для PowerShell 5.1.

---

### Вариант 1: Локальные модули (Рекомендуется для конкретного проекта)

Если ваш модуль нужен только для этого конкретного скрипта или проекта, лучше всего держать его внутри рабочей
папки.

#### 1. Организуйте структуру папок
Важно соблюдать правило: **Имя папки модуля должно совпадать с именем файла (без расширения)**. Это позволяет
PowerShell корректно определять модуль.

Структура должна выглядеть так:
```text
c:\work\myScript\
├── main.ps1              <-- Ваш главный скрипт
└── Modules\              <-- Создаем папку для модулей
    └── MyCompanyUtils\   <-- Папка с ИМЕНЕМ модуля
        └── MyCompanyUtils.psm1  <-- Сам файл модуля
```

#### 2. Как импортировать в скрипт `main.ps1`
Так как папка `c:\work\myScript\Modules` не находится в стандартных путях PowerShell (`$env:PSModulePath`),
автозагрузка тут не сработает. Вам нужно указать полный путь.

В PowerShell 5.1 всегда используйте переменную `$PSScriptRoot`. Она указывает на папку, где лежит выполняемый
скрипт (`main.ps1`). Это надежнее, чем писать жесткий путь `C:\work...`, так как если вы перенесете папку проекта
в `D:\dev\`, скрипт перестанет работать с жесткими путями, но с `$PSScriptRoot` — продолжит.

**Код внутри `main.ps1`:**
```powershell
# 1. Собираем путь к модулю динамически
$modulePath = Join-Path -Path $PSScriptRoot -ChildPath "Modules\MyCompanyUtils"

# 2. Проверяем, существует ли папка (для надежности)
if (Test-Path $modulePath) {
    # 3. Импортируем модуль по полному пути
    Import-Module $modulePath -Force
    Write-Host "Модуль успешно загружен" -ForegroundColor Green
} else {
    Write-Error "Модуль не найден по пути: $modulePath"
}

# Теперь можно вызывать функции из модуля
Invoke-MyFunction
```

**Почему это best practice:**
Вы можете вызывать `Import-Module $modulePath`, указывая путь к **папке**. PowerShell сам найдет внутри `.psm1`
файл (или `.psd1`, если есть), так как имя папки и файла совпадают.

---

### Вариант 2: Глобальные модули (Для общего использования)

Если этот модуль — ваша личная библиотека функций, которую вы хотите использовать в *любом* скрипте на этом
компьютере, не копируя её в каждую папку.

#### 1. Куда класть файлы
В PowerShell 5.1 есть специальная папка для модулей текущего пользователя. Обычно это:
`C:\Users\<YourUserName>\Documents\WindowsPowerShell\Modules\`

Создайте там структуру:
```text
Documents\WindowsPowerShell\Modules\
└── MyCompanyUtils\
    └── MyCompanyUtils.psm1
```
*(Если папки `WindowsPowerShell\Modules` нет, создайте их вручную).*

#### 2. Как импортировать в скрипт `main.ps1`
Теперь, когда модуль лежит в "правильном" системном месте, вам вообще не нужно указывать пути. PowerShell найдет
его сам.

**Код внутри `main.ps1`:**
```powershell
# Просто импортируем по имени. PowerShell сам найдет путь в переменной $env:PSModulePath
Import-Module MyCompanyUtils

# Если модуль уже был загружен ранее, -Force заставит перечитать файл (полезно при разработке)
# Import-Module MyCompanyUtils -Force

Invoke-MyFunction
```

---

### Продвинутый трюк: Динамическое добавление пути (Гибридный вариант)

Если вы хотите держать модуль в папке проекта (Вариант 1), но хотите вызывать его просто по имени (как в Варианте
2), не писая длинные `Join-Path`, вы можете временно добавить папку `Modules` в переменную окружения
`$env:PSModulePath` прямо в начале скрипта.

**Код внутри `main.ps1`:**
```powershell
# Определяем путь к папке с модулями относительно скрипта
$localModulesPath = Join-Path $PSScriptRoot "Modules"

# Если этого пути еще нет в системном списке модулей, добавляем его временно для этой сессии
if ($env:PSModulePath -notlike "*$localModulesPath*") {
    $env:PSModulePath = "$localModulesPath;$env:PSModulePath"
}

# Теперь можно импортировать просто по имени, как будто он установлен глобально!
Import-Module MyCompanyUtils
```

### Резюме для вашего случая (`c:\work\myScript\`)

1.  Создайте папку `Modules` рядом с `main.ps1`.
2.  Внутри создайте папку с именем модуля (например, `MyLib`).
3.  Положите `MyLib.psm1` внутрь.
4.  В `main.ps1` напишите:
    ```powershell
    Import-Module (Join-Path $PSScriptRoot "Modules\MyLib")
    ```

Это самый надежный, переносимый и профессиональный способ для скриптов, которые живут в рабочих папках.

-------------
В корпоративной среде с жесткими требованиями безопасности (Enterprise Security) подход "папка рядом со скриптом"
(локальные модули) считается **плохой практикой** и часто запрещен политиками безопасности.

Почему?
1.  **Сложность аудита:** Если каждый скрипт тащит с собой свою библиотеку, у вас будет 50 копий одного и того же
модуля. Обновить версию (например, из-за бага или уязвимости) — кошмар.
2.  **Execution Policy:** В корпорациях часто стоит политика `AllSigned` или `Restricted`. Копирование модулей в
локальные папки может требовать постоянной разблокировки файлов (`Unblock-File`).
3.  **Целостность:** Локальные файлы проще подменить злоумышленнику, если у пользователя есть права на запись в
рабочую папку.

Для корпоративной среды я рекомендую следующую стратегию: **Централизованное хранение и управление.**

---

### Стратегия 1: Системное развертывание (Рекомендуемый "Gold Standard")

Вместо того чтобы модуль traveling (путешествовал) со скриптом, модуль должен быть установлен как часть
стандартного софта на машине (как драйвер или драйвер принтера).

#### 1. Размещение
Используйте системную папку `Program Files`, доступную только для чтения (Read-Only) для обычных пользователей.
```text
C:\Program Files\WindowsPowerShell\Modules\
└── MyCorpUtils\
    ├── 1.0.0\
    │   └── MyCorpUtils.psm1
    └── MyCorpUtils.psd1
```

#### 2. Доставка
Не копируйте файлы руками. Используйте системы деплоя:
*   **SCCM (System Center Configuration Manager)** / **MECM**: Создайте приложение, которое распаковывает модуль в
`Program Files`.
*   **Intune**: Для управляемых компьютеров используйте Win32 Apps.
*   **Group Policy (GPO) с Startup Script:** Скрипт запуска копирует файлы из безопасной сетевой шары в локальную
папку при старте ПК (если нет SCCM).

#### 3. Использование в скрипте
Ваш скрипт `c:\work\myScript\main.ps1` становится максимально чистым:
```powershell
# Мы просто вызываем модуль по имени. Он находится в надежном системном месте.
Import-Module MyCorpUtils

# Если вам строго нужна определенная версия (чтобы избежать поломок при обновлении):
Import-Module MyCorpUtils -RequiredVersion 1.0.0
```

---

### Стратегия 2: Централизованное сетевое хранилище (Network Share)

Если у вас много скриптов, которые обновляются ежедневно, и деплоить их через SCCM слишком долго, используйте
сетевое хранилище.

#### 1. Размещение
Создайте DFS-шару (Distributed File System) с доступом только на чтение (Read) для пользователей и запись (Write)
только для группы администраторов/DevOps.
```text
\\corp.net\dfs\PowerShell\Modules\
└── MyCorpUtils\
    └── MyCorpUtils.psm1
```

#### 2. Настройка путей (PSModulePath)
Вам не нужно прописывать полные пути в скриптах. Вам нужно один раз настроить среду через **GPO (Group Policy)**:
1.  Откройте GPO: `Computer Configuration` -> `Administrative Templates` -> `Windows Components` -> `Windows
PowerShell`.
2.  Включите политику **"Set Module Path"** (если доступна) или, что надежнее, добавьте путь через переменную
среды в GPO:
    `Computer Configuration` -> `Preferences` -> `Windows Settings` -> `Environment`.
    Имя переменной: `PSModulePath`
    Значение: `%SystemRoot%\system32\WindowsPowerShell\v1.0\Modules\;\\corp.net\dfs\PowerShell\Modules\`

#### 3. Использование
Поскольку сетевая папка теперь прописана в `$env:PSModulePath` на всех машинах через GPO, скрипты снова работают
просто по имени:
```powershell
# PowerShell сам найдет модуль в сетевой шаре
Import-Module MyCorpUtils
```

---

### Критические элементы безопасности (Must Have)

В корпоративной среде недостаточно просто положить файлы. Вам нужно защитить их от изменений.

#### 1. Цифровая подпись кода (Code Signing)
Это обязательное требование для большинства банков и предприятий.
*   **Требование:** Политика Execution Policy должна быть установлена в `AllSigned` (через GPO).
*   **Действие:** Все ваши `.psm1` и `.ps1` должны быть